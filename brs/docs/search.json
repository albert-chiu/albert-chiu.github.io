[{"path":"/articles/brs-vignette.html","id":"installing-brs-and-python","dir":"Articles","previous_headings":"","what":"Installing {brs} and Python","title":"brs: Bayesian Rule Set","text":"{brs} currently CRAN thus must installed GitHub. can done using following code: {brs} uses source code written Python requires, addition package , installation Python. recommend miniforge due variety CPU architectures support, hopefully preempt incompatibility errors otherwise arise, although installation works .","code":"#devtools::install_github(\"albert-chiu/brs\")"},{"path":"/articles/brs-vignette.html","id":"preliminaries","dir":"Articles","previous_headings":"","what":"Preliminaries","title":"brs: Bayesian Rule Set","text":"{brs} uses reticulate package run source code written Python requires bit setup. experience, find process can vary depending hardware software may require trouble-shooting.","code":"# First create conda environment  # do this *before* loading the brs package. If you've already loaded brs or  #   have been using reticulate, you may need to restart R and rerun your code #   in the order shown below # Note: this code is for computers with Apple silicon (M1, etc.) and the  #   corresponding miniforge installation   # install python and packages to environment # note: this requires an Internet connection reticulate::conda_install(envname = \"~/miniforge3/envs/BRS_conda\",   conda=\"~/miniforge3/condabin/conda\",  # path to conda binary   packages = c(\"numpy\", \"pandas\", \"scikit-learn\", \"scipy\")) #> + '/Users/albertchiu/miniforge3/bin/conda' 'install' '--yes' '--prefix' '/Users/albertchiu/miniforge3/envs/BRS_conda' '-c' 'conda-forge' 'numpy' 'pandas' 'scikit-learn' 'scipy' reticulate::use_condaenv(condaenv=\"~/miniforge3/envs/BRS_conda\")    # load brs package library(brs)"},{"path":"/articles/brs-vignette.html","id":"running-the-brs-algorithm","dir":"Articles","previous_headings":"","what":"Running the BRS algorithm","title":"brs: Bayesian Rule Set","text":"BRS algorithm requires number hyperparameters (see references). function default values maximum length rule. , must supply BRS function dataframe containing explanatory variables separate outcome vector. function output list three entries. first rule sets . bootstrap, one rule set, formatted list vectors, vector corresponds rule. bootstrap, first return entry list lists. second entry list indices observations used bootstrapped sample. functions package access indices, likely much interest independent . bootstrap, second entry empty. third entry dataframe --sample performance statistics. choose use train/test split (default), function fit rule set training set evaluate accuracy, true positive rate (tpr), false positive rate (fpr) test set. Otherwise, come back populated NaNs. can also bootstrap obtain many rule sets. using remainder vignette.","code":"set.seed(123) # load data for example data(\"lipset_df\", \"lipset_Y\")    # BRS without bootstrapping on entire sample print(brs::BRS(df = lipset_df, Y = lipset_Y, seed = 123, maxLen=3L,                 trainProp = 1, bootstrap = F)) #> $`Rule Sets` #> $`Rule Sets`$`0` #> $`Rule Sets`$`0`[[1]] #> [1] \"LITERACY_0_neg\" \"GNPCAP_0_neg\"   #>  #>  #>  #> $Indices #> named list() #>  #> $Stats #>   accuracy tpr fpr #> 1      NaN NaN NaN # BRS without bootstrapping, with train/test split print(brs::BRS(df = lipset_df, Y = lipset_Y, seed = 123, maxLen=3L,                 bootstrap = F))  # default split is .7 training/.3 test #> $`Rule Sets` #> $`Rule Sets`$`0` #> $`Rule Sets`$`0`[[1]] #> [1] \"INDLAB_1\"       \"URBANIZA_0_neg\" \"GNPCAP_1_neg\"   #>  #> $`Rule Sets`$`0`[[2]] #> [1] \"GNPCAP_0_neg\" \"URBANIZA_0\"   #>  #>  #>  #> $Indices #> named list() #>  #> $Stats #>    accuracy tpr  fpr #> 1 0.6666667 0.5 0.25 # run BRS with default parameters out_lipset <- brs::BRS(df = lipset_df, Y = lipset_Y, seed = 123,                         maxLen=3L, bootstrap = T, reps=100L) out_lipset[[\"Rule Sets\"]][1:5 ] #> $`0` #> $`0`[[1]] #> [1] \"GNPCAP_1_neg\"   \"LITERACY_0_neg\" \"GNPCAP_0_neg\"   #>  #> $`0`[[2]] #> [1] \"INDLAB_1_neg\" \"GNPCAP_0_neg\" #>  #>  #> $`1` #> $`1`[[1]] #> [1] \"GNPCAP_0_neg\" #>  #>  #> $`2` #> $`2`[[1]] #> [1] \"LITERACY_0_neg\" \"GNPCAP_0_neg\"   #>  #>  #> $`3` #> $`3`[[1]] #> [1] \"URBANIZA_0_neg\" #>  #>  #> $`4` #> $`4`[[1]] #> [1] \"INDLAB_1_neg\"   \"LITERACY_0_neg\" \"GNPCAP_1\"       #>  #> $`4`[[2]] #> [1] \"URBANIZA_0_neg\" out_lipset[[\"Indices\"]][1:5 ] #> $`0` #>  [1] 13  2  2  6 17 10  1  0 17 15  9  0 14  0 15 14  4  0 #>  #> $`1` #>  [1]  7 11 14 11  8  9  3 13  5  3 11 11  5  1 16 13 10 14 #>  #> $`2` #>  [1] 12  1 17 15 10  1 11  0  6  1 16 15  1  5  3 12  9  6 #>  #> $`3` #>  [1]  7 15  0 17  4 10  9 14  8  5  8  4 17 14 12  5  0 17 #>  #> $`4` #>  [1]  4  1  7 12  2 11 12 15  4  8 16 12 12  5  3  9  1  4 out_lipset[[\"Stats\"]][1:5, ] #>    accuracy       tpr       fpr #> 1         1         1         0 #> 2         1         1         0 #> 3 0.8333333         1       0.2 #> 4       0.5         0      0.25 #> 5       0.5 0.3333333 0.3333333"},{"path":"/articles/brs-vignette.html","id":"creating-a-bar-graph","dir":"Articles","previous_headings":"","what":"Creating a bar graph","title":"brs: Bayesian Rule Set","text":"visualize bootstrapped rule sets, recommend first making bar graph. create graph, need create objects help function label simplify features. First, need create dataframe labels variables. Next, optionally can simplify features equivalent defining equivalence classes. can skip set (set simplify argument plot_bar function FALSE) find burdensome, recommend serious stage research process. example, binary variable \\(X\\), can change rules ‘\\(X\\)=0’ ‘\\(X\\)=1’ rules ‘\\(X=1\\)’ ‘\\(X=0\\).’ , need two objects: list (vectors ) variable names oppind matrix values oppmat. \\(\\)th index oppind corresponds \\(\\)th row oppmat. oppmat two columns, containing one two possible values binary variables respective entry oppind. democracy example, three binary variables (variables) like create equivalence classes: variables can take either value 0 1. possible duos values, e.g., variable like GNPCAP three possible values, ‘low,’ ‘med,’ ‘high,’ create overlapping binary categories ‘low,’ ‘medium high,’ ‘high’ (example ), another duo might ‘low’ ‘medium high.’ require row oppmat entry oppind. also ‘low medium’ category, require separate entry. example: Finally, can make barplot (see documentation thurough explanation argument, well default values):","code":"fdf <- cbind(colnames(lipset_df),              c(\"Wealth (high)\", \"Wealth (med)\", \"Wealth (low)\",                \"Urbanization (high)\", \"Urbanization (low)\",                 \"Education (high)\", \"Education (low)\",                 \"Industrialization (high)\", \"Industrialization (low)\"))  # a low effort stopgap is to use the variable names as they appear in your data: # fdf <- cbind(colnames(lipset_df), colnames(lipset_df)) # create  #oppind <- list(unique(unlist(lapply(colnames(lipset_df),                  #function(x) strsplit(x, \"_\")[[1]][[1]])))[2:4]) oppind <- list(c(\"URBANIZA\", \"LITERACY\", \"INDLAB\")) oppmat <- matrix(c(0,1), nrow=1) oppind_lmh <- list(c(\"GNPCAP\"),                   c(\"GNPCAP\")) oppmat_lmh <- rbind(c(\"low\", \"med_or_high\"),                      c(\"low_or_med\", \"high\"))  print(oppind_lmh) #> [[1]] #> [1] \"GNPCAP\" #>  #> [[2]] #> [1] \"GNPCAP\" print(oppmat_lmh) #>      [,1]         [,2]          #> [1,] \"low\"        \"med_or_high\" #> [2,] \"low_or_med\" \"high\" lipset_bar <- brs::plot_bar(df = lipset_df, Y=lipset_Y, fit = out_lipset,      featureLabels = fdf, maxLen=3, boot_rep = 100L,     minProp = .05,  # rules must appear in at least 5% of bootstraps     topRules=5,  # plot at most the top five rules of each length     simplify = T, oppmat=oppmat, oppind=oppind,      and =\" & \",  # how to display the 'and' operator     plotBuffer = c(.25, 0, .4),  # white spacing around plot     titleSize=10, rule_text_size = 10, number_size = 10)  # visual parameters print(lipset_bar)"},{"path":"/articles/brs-vignette.html","id":"making-a-chord-diagram","dir":"Articles","previous_headings":"","what":"Making a chord diagram","title":"brs: Bayesian Rule Set","text":"visualize interactions present single rule set, recommend using chord diagram. either rule set found without bootstrapping, aggregated rule set bootstrapping. plot latter (though example ). Note graph agnostic obtain rule set, meaning can also used QCA method. plot chord diagram, also need create dataframe maps variable names appear data (first column) variable names want appear graph (second column). obtain plot aggregated rule set.","code":"# Feature names (without values) as they appear in X and their corresponding labels fgs <- cbind(unique(unlist(lapply(colnames(lipset_df), function(x) strsplit(x, \"_\")[[1]][[1]]))),              c(\"Wealth\", \"Urbanization\", \"Education\", \"Industrialization\")) fgs #>      [,1]       [,2]                #> [1,] \"GNPCAP\"   \"Wealth\"            #> [2,] \"URBANIZA\" \"Urbanization\"      #> [3,] \"LITERACY\" \"Education\"         #> [4,] \"INDLAB\"   \"Industrialization\" # get aggregated rule set ruleset <- brs::agg_BRS(fit = out_lipset, X = lipset_df, Y=lipset_Y, maxLen=3) plot_chord(ruleSet=ruleset, featureGroups=fgs,            #linkColors=RColorBrewer::brewer.pal(11, \"RdGy\")[c(8,10)],             linkColors=RColorBrewer::brewer.pal(9, \"Set3\")[c(6,5)],             gridColors = \"grey\",             textSize = 1, side_mar=0, top_mar=0)"},{"path":"/articles/brs-vignette.html","id":"making-a-t-sne-plot","dir":"Articles","previous_headings":"","what":"Making a t-SNE plot","title":"brs: Bayesian Rule Set","text":"Finally, make t-SNE plot help visualize raw data low dimensional way. recomend accompanying reference paper package, use variables included final (aggregated) rule set.","code":"set.seed(123) plot_tsne(X = lipset_df, Y = lipset_Y, ruleSet=ruleset,           pointSize = 1.25, symb = c(20, 4),           caseColors=RColorBrewer::brewer.pal(11, \"RdYlGn\")[c(2,9)])"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Albert Chiu. Author, maintainer. Yiqing Xu. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chiu , Xu Y (2023). brs: Bayesian Rule Set. R package version 0.0.0.9007.","code":"@Manual{,   title = {brs: Bayesian Rule Set},   author = {Albert Chiu and Yiqing Xu},   year = {2023},   note = {R package version 0.0.0.9007}, }"},{"path":"/reference/BRS.html","id":null,"dir":"Reference","previous_headings":"","what":"Run BRS — BRS","title":"Run BRS — BRS","text":"function runs BRS. allows user either run BRS original data run BRS bootstrapped samples","code":""},{"path":"/reference/BRS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run BRS — BRS","text":"","code":"BRS(   df,   Y,   maxLen,   trainProp,   numIter = 500L,   numChain = 2L,   numMine = 5000L,   supp = 5L,   alpha_1 = 50L,   beta_1 = 1L,   alpha_2 = 50L,   beta_2 = 1L,   prior_type = \"beta\",   alpha_l = NULL,   beta_l = NULL,   lambda = NULL,   nu = NULL,   print = FALSE,   bootstrap = FALSE,   reps = 1L,   sampleSize = NULL,   seed = NULL )"},{"path":"/reference/BRS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run BRS — BRS","text":"df dataframe binary features Y vector binary outcome maxLen integer maximum length rules trainProp numeric proportion data use training data numIter integer number iterations simulated annealing numChain integer number chains simulated annealing numMine integer number rules mine supp integer percent minimum support alpha_1 numeric alpha_+ paper beta_1 beta_+ alpha_2 alpha_- beta_2 beta_- prior_type string prior type. Either \"beta\" BRS-BetaBinomial \"poisson\" BRS-Poisson alpha_l vector alpha_l l=1...maxLen. set NULL prior_type=\"beta\", values automatically generated. Ignored prior_type=\"poisson\" beta_l vector beta_l l=1...maxLen. set NULL prior_type=\"beta\", values automatically generated. Ignored prior_type=\"poisson\" lambda numeric rate parameter prior number rules nu numeric rate parameter prior length rules print logical whether print progress algorithm bootstrap logical whether bootstrap reps integer number bootstrap reps sampleSize integer bootstrap sample size. set NULL, default number observations data","code":""},{"path":"/reference/BRS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run BRS — BRS","text":"list rule sets bootstrap replications indices bootstrap samples accuracy, true positive rate, false positive rate test data rule set","code":""},{"path":"/reference/agg_BRS.html","id":null,"dir":"Reference","previous_headings":"","what":"Find aggregate rule set — agg_BRS","title":"Find aggregate rule set — agg_BRS","text":"Find aggregate rule set list bootstrapped BRS rule sets","code":""},{"path":"/reference/agg_BRS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find aggregate rule set — agg_BRS","text":"","code":"agg_BRS(   fit,   X,   Y,   maxLen,   split = F,   train = 0.7,   maxRules = 3,   stat = \"acc\",   topRules = 5,   minProp = 0,   simplify = F,   oppmat = NULL,   oppind = NULL )"},{"path":"/reference/agg_BRS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find aggregate rule set — agg_BRS","text":"fit output BRS function. list whose first element list rule sets whose second element list bootstrap indices. third element ignored. X data frame matrix data, excluding outcome Y vector outcomes maxLen maximum length rule possible split logical whether split sample training set aggregate rule set found test set rule set's performance evaluated train numeric proportion data use training data. split=F, argument ignored. maxRules integer maximum number rules aggregate rule set stat statistic evaluate aggregated rule sets. Currently accuracy supported topRules integer number high prevalence rules length consider minProp numeric proportion times rule must appear order considered simplify logical whether equivalent rules combined determining prevalence oppmat matrix two columns K rows, K length list oppind. kth row contains values v1 v2 (.e., v1=oppmat[k,1] v2=oppmat[k,2]) variable var oppind[[k]], var_v1 !var_v2 equivalent. v1 prefered return value. oppind list vectors variables. vector oppind[[k]] contains variables var var_v1 !var_v2 equivalent, v1 v2 form kth row oppmat, v1=oppmat[k,1] v2=oppmat[k,2]","code":""},{"path":"/reference/agg_BRS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find aggregate rule set — agg_BRS","text":"aggregate rule set, highest stat possible rule sets constructed maxRules candidate rules","code":""},{"path":"/reference/dot-amat.html","id":null,"dir":"Reference","previous_headings":"","what":"Make an Adjacency Matrix — .amat","title":"Make an Adjacency Matrix — .amat","text":"Make Adjacency Matrix","code":""},{"path":"/reference/dot-amat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make an Adjacency Matrix — .amat","text":"","code":".amat(allRuleSets, featureGroups, maxLen, minProp)"},{"path":"/reference/dot-amat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make an Adjacency Matrix — .amat","text":"adjacency matrix","code":""},{"path":"/reference/dot-getFP.html","id":null,"dir":"Reference","previous_headings":"","what":"Get proportion of false positives — .getFP","title":"Get proportion of false positives — .getFP","text":"Get proportion false positives","code":""},{"path":"/reference/dot-getFP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get proportion of false positives — .getFP","text":"","code":".getFP(rules, allIndices, reps, df, Y)"},{"path":"/reference/dot-getTP.html","id":null,"dir":"Reference","previous_headings":"","what":"Get proportion of true positives — .getTP","title":"Get proportion of true positives — .getTP","text":"Get proportion true positives","code":""},{"path":"/reference/dot-getTP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get proportion of true positives — .getTP","text":"","code":".getTP(rules, allIndices, reps, df, Y)"},{"path":"/reference/dot-get_df_chord.html","id":null,"dir":"Reference","previous_headings":"","what":"Make data frame for circilize — .get_df_chord","title":"Make data frame for circilize — .get_df_chord","text":"Make data frame circilize","code":""},{"path":"/reference/dot-get_df_chord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make data frame for circilize — .get_df_chord","text":"","code":".get_df_chord(allRuleSets, featureGroups, maxLen, minProp)"},{"path":"/reference/dot-get_df_chord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make data frame for circilize — .get_df_chord","text":"data frame","code":""},{"path":"/reference/dot-importBRS.html","id":null,"dir":"Reference","previous_headings":"","what":"Import BRS from Python — .importBRS","title":"Import BRS from Python — .importBRS","text":"testing purposes. function imports Python code required running BRS","code":""},{"path":"/reference/dot-importBRS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import BRS from Python — .importBRS","text":"","code":".importBRS()"},{"path":"/reference/getLabel.html","id":null,"dir":"Reference","previous_headings":"","what":"Get labels for features — getLabel","title":"Get labels for features — getLabel","text":"Get labels features use graphs","code":""},{"path":"/reference/getLabel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get labels for features — getLabel","text":"","code":"getLabel(feat, labels_df, neg_label)"},{"path":"/reference/getLabel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get labels for features — getLabel","text":"feat feature vector features get label ; form \"feature_value\" labels_df dataframe unique feature corresponding labels; first column feature, second column corresponding label neg_label prefix use negative features","code":""},{"path":"/reference/getLabel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get labels for features — getLabel","text":"label use feat","code":""},{"path":"/reference/numCases.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the number of cases that satisfy a rule — numCases","title":"Get the number of cases that satisfy a rule — numCases","text":"Get number cases satisfy rule","code":""},{"path":"/reference/numCases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the number of cases that satisfy a rule — numCases","text":"","code":"numCases(rule, df, Y = NULL, y_val = 1)"},{"path":"/reference/numCases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the number of cases that satisfy a rule — numCases","text":"rule rule check: must format feature_value feature_value_neg df data check Y included, checks case's Y=y_val y_val value Y take","code":""},{"path":"/reference/numCases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the number of cases that satisfy a rule — numCases","text":"number cases data satisfies rule","code":""},{"path":"/reference/plot_bar.html","id":null,"dir":"Reference","previous_headings":"","what":"Make bar plot — plot_bar","title":"Make bar plot — plot_bar","text":"function makes bar plot rule frequency coverage","code":""},{"path":"/reference/plot_bar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make bar plot — plot_bar","text":"","code":"plot_bar(   df,   Y,   fit,   featureLabels,   maxLen,   topRules = 10,   and = \" AND \",   neg = \"NOT \",   minProp = 0,   simplify = T,   oppmat = NULL,   oppind = NULL,   heightBuffer = 1,   plotBuffer = 0,   textSize = 16,   boot_rep = 100 )"},{"path":"/reference/plot_bar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make bar plot — plot_bar","text":"df dataframe binary features Y vector binary outcome fit output function BRS featureLabels data frame whose first column feature names (appear df) whose second column corresponding labels displayed graph maxLen integer maximum length rules topRules max number rules plot length string \"\" statement concatenated neg string \"\" statement prefaced minProp minimum proportion rule sets rule must appear plotted simplify whether simplify negative rules possible. true, negative rule changed positive counterpart two possible values corresponding variable (e.g. \"A_1_neg\" changed \"A_0\" two possible values \"\" 0 1) heightBuffer amount shift bottom graph make room label textSize size parameter passed ggplot2::element_text","code":""},{"path":"/reference/plot_bar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make bar plot — plot_bar","text":"bar plot frequency coverage rules","code":""},{"path":"/reference/plot_chord.html","id":null,"dir":"Reference","previous_headings":"","what":"Make Chord Diagram — plot_chord","title":"Make Chord Diagram — plot_chord","text":"Makes chord diagram representing frequency interactions features","code":""},{"path":"/reference/plot_chord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make Chord Diagram — plot_chord","text":"","code":"plot_chord(   fit,   featureNames,   featureGroups,   linkColors,   gridColors,   bgLinkColor = \"gray\",   maxLen,   lengths = c(1:maxLen),   dims = c(1, maxLen),   minProp = 0,   textSize = 1,   line_arg = 1,   side_mar = 0,   top_mar = 0 )"},{"path":"/reference/plot_chord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make Chord Diagram — plot_chord","text":"fit output function BRS featureNames names features appeared df featureGroups dataframe whose first column features (prefixes, values) featureNames whose second column corresponding labels display linkColors vector colors use chords gridColors vector colors use arcs minProp minimum proportion times relationship must appear plotted textSize cex parameter passed par","code":""},{"path":"/reference/plot_chord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make Chord Diagram — plot_chord","text":"chord diagram","code":""},{"path":"/reference/plot_tsne.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a t-SNE plot — plot_tsne","title":"Make a t-SNE plot — plot_tsne","text":"Makes t-SNE plot color coding classification correctness shading predicted outcome","code":""},{"path":"/reference/plot_tsne.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a t-SNE plot — plot_tsne","text":"","code":"plot_tsne(   df,   Y,   A,   caseColors,   boxColor,   pointSize = 1,   textSize = 1,   symb = 19,   bottom_buffer = 1.25,   all_buffer = 1,   legend_under_plot = T,   legend_bg_col = \"transparent\",   legend_offset = c(0, 0),   legend_position = \"bottomright\",   shade_name = \"Positive classification\",   jitter_factor = 1,   jitter_amount = NULL,   max_iter = 1000 )"},{"path":"/reference/plot_tsne.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a t-SNE plot — plot_tsne","text":"df dataframe binary features Y vector binary outcome rule set use determining variables used training t-SNE (use outcome plus variables appear ) caseColors vector colors use classification correctness. first element correct, second incorrect boxColor color shading pointSize cex paramater plot size points textSize cex paramater legend size text symb pch paramater plot symbol points bottom_buffer amount shift bottom graph legend all_buffer buffer sides plot legend_under_plot whether legend plot inside plot. Overrides legend_coordinates legend_bg_col background color legend legend_offset distance move legend (percentage). Negative values move legend left , positive values move legend right . legend_under_plot=F, argument analagous inset arguement plot legend_position position legend shade_name label legend shaded points jitter_factor factor jitter points jitter_amount amount jitter points max_iter maximum number iterations run t-SNE","code":""},{"path":"/reference/plot_tsne.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a t-SNE plot — plot_tsne","text":"t-SNE plot","code":""},{"path":"/reference/simplifyFeature.html","id":null,"dir":"Reference","previous_headings":"","what":"Function that simplifies feature if possible — simplifyFeature","title":"Function that simplifies feature if possible — simplifyFeature","text":"Function simplifies feature possible","code":""},{"path":"/reference/simplifyFeature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function that simplifies feature if possible — simplifyFeature","text":"","code":"simplifyFeature(originalFeature, featureNames, featureValues)"},{"path":"/reference/simplifyFeature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function that simplifies feature if possible — simplifyFeature","text":"originalFeature feature simplify featureNames vector feature names, repeated according multiplicity featureValues vector values corresponding features (order featureNames)","code":""},{"path":"/reference/simplifyFeature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function that simplifies feature if possible — simplifyFeature","text":"name feature use Original feature _neg suffix _neg suffix: original feature value none multiple alternative values, feature value exactly one alternative","code":""}]
